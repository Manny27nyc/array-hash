<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>array-hash: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">array-hash
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">array-hash Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/Tessil/array-hash"></a> <a href="https://ci.appveyor.com/project/Tessil/array-hash/branch/master"></a></p>
<h2>A C++ implementation of a fast and memory efficient hash map/set for strings</h2>
<p>Cache conscious hash map and hash set for strings based on the "Cache-conscious collision resolution in string hash tables." (Askitis Nikolas and Justin Zobel, 2005) paper. You can find some details regarding the structure <a href="https://tessil.github.io/2017/06/22/hat-trie.html#array-hash-table">here</a>.</p>
<p>Thanks to its cache friendliness, the structure provides fast lookups while keeping a low memory usage. The main drawback is the rehash process which is a bit slow and need some spare memory to copy the strings from the old hash table to the new hash table (it canâ€™t use <code>std::move</code> as the other hash tables using <code>std::string</code> as key).</p>
<div class="image">
<img src="https://tessil.github.io/images/array_hash.png" width="500px"/>
</div>
 <p>Four classes are provided: <code><a class="el" href="classtsl_1_1array__map.html">tsl::array_map</a></code>, <code><a class="el" href="classtsl_1_1array__set.html">tsl::array_set</a></code>, <code><a class="el" href="namespacetsl.html#ac1a9ea8631baa6e45199f6f671822d1d">tsl::array_pg_map</a></code> and <code><a class="el" href="namespacetsl.html#a98a91da99356329b6221f7f429c10a76">tsl::array_pg_set</a></code>. The first two are faster and use a power of two growth policy, the last two use a prime growth policy instead and are able to cope better with a poor hash function. Use the prime version if there is a chance of repeating patterns in the lower bits of your hash (e.g. you are storing pointers with an identity hash function). See <a href="https://github.com/Tessil/array-hash#growth-policy">GrowthPolicy</a> for details.</p>
<p>A <b>benchmark</b> of <code><a class="el" href="classtsl_1_1array__map.html">tsl::array_map</a></code> against other hash maps can be found <a href="https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html">here</a>. This page also gives some advices on which hash table structure you should try for your use case (useful if you are a bit lost with the multiple hash tables implementations in the <code>tsl</code> namespace). You can also find another benchmark on the <a href="https://github.com/Tessil/hat-trie#benchmark"><code>tsl::hat-trie</code></a> page.</p>
<h3>Overview</h3>
<ul>
<li>Header-only library, just add the <a href="include/">include</a> directory to your include path and you are ready to go. If you use CMake, you can also use the <code>tsl::array_hash</code> exported target from the <a href="CMakeLists.txt">CMakeLists.txt</a>.</li>
<li>Low memory usage with good performances, see the <a href="https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html">benchmark</a> for some numbers.</li>
<li>Support for move-only and non-default constructible values.</li>
<li>Strings with null characters inside them are supported (you can thus store binary data as key).</li>
<li>If the hash is known before a lookup, it is possible to pass it as parameter to speed-up the lookup (see <code>precalculated_hash</code> parameter in <a href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1array__map.html">API</a>).</li>
<li>By default the maximum allowed size for a key is set to 65 535. This can be raised through the <code>KeySizeT</code> template parameter (see <a href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1array__map.html#details">API</a> for details).</li>
<li>By default the maximum size of the map is limited to 4 294 967 296 elements. This can be raised through the <code>IndexSizeT</code> template parameter (see <a href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1array__map.html#details">API</a> for details).</li>
</ul>
<h3>Differences compare to <code>std::unordered_map</code></h3>
<p><code><a class="el" href="classtsl_1_1array__map.html">tsl::array_map</a></code> tries to have an interface similar to <code>std::unordered_map</code>, but some differences exist:</p><ul>
<li>Iterator invalidation doesn't behave in the same way, any operation modifying the hash table invalidate them (see <a href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1array__map.html#details">API</a> for details).</li>
<li>References and pointers to keys or values in the map are invalidated in the same way as iterators to these keys-values.</li>
<li>Erase operations have an amortized runtime complexity of O(1) for <code><a class="el" href="classtsl_1_1array__map.html">tsl::array_map</a></code>. An erase operation will delete the key immediatly but for the value part of the map, the deletion may be delayed. The destructor of the value is only called when the ratio between the size of the map and the size of the map + the number of deleted values still stored is low enough. The method <code>shrink_to_fit</code> may be called to force the deletion.</li>
<li>The key and the value are stored separatly and not in a <code>std::pair&lt;const Key, T&gt;</code>. Methods like <code>insert</code> or <code>emplace</code> take the key and the value separatly instead of a <code>std::pair</code>. The insert method looks like <code>std::pair&lt;iterator, bool&gt; insert(const CharT* key, const T&amp; value)</code> instead of <code>std::pair&lt;iterator, bool&gt; insert(const std::pair&lt;const Key, T&gt;&amp; value)</code> (see <a href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1array__map.html">API</a> for details).</li>
<li>For iterators, <code>operator*()</code> and <code>operator-&gt;()</code> return a reference and a pointer to the value <code>T</code> instead of <code>std::pair&lt;const Key, T&gt;</code>. For an access to the key string, the <code>key()</code> (which returns a <code>const CharT*</code>) or <code>key_sv()</code> (which returns a <code>std::basic_string_view&lt;CharT&gt;</code>) method of the iterator must be called.</li>
<li>No support for some bucket related methods (like <code>bucket_size</code>, <code>bucket</code>, ...).</li>
</ul>
<p>These differences also apply between <code>std::unordered_set</code> and <code><a class="el" href="classtsl_1_1array__set.html">tsl::array_set</a></code>.</p>
<p>Thread-safety and exception guarantees are similar to the STL containers.</p>
<h3>Hash function</h3>
<p>To avoid dependencies, the default hash function is a simple <a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash">FNV-1a</a> hash function. If you can, we recommend to use something like <a href="https://github.com/google/cityhash">CityHash</a>, MurmurHash, <a href="https://github.com/google/farmhash">FarmHash</a>, ... for better performances. On the tests we did, CityHash64 offers a ~40% improvement on reads compared to FNV-1a.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;city.h&gt;</div><div class="line"></div><div class="line">struct str_hash {</div><div class="line">    std::size_t operator()(const char* key, std::size_t key_size) const {</div><div class="line">        return CityHash64(key, key_size);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">tsl::array_map&lt;char, int, str_hash&gt; map;</div></div><!-- fragment --><p>If you have access to <code>std::string_view</code> and you want to use the compiler provided hash implementation for strings.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;string_view&gt;</div><div class="line"></div><div class="line">struct str_hash {</div><div class="line">    std::size_t operator()(const char* key, std::size_t key_size) const {</div><div class="line">        return std::hash&lt;std::string_view&gt;()(std::string_view(key, key_size));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">tsl::array_map&lt;char, int, str_hash&gt; map;</div></div><!-- fragment --><p>The <code>std::hash&lt;std::string&gt;</code> can't be used efficiently as the structure doesn't store any <code>std::string</code> object. Any time a hash would be needed, a temporary <code>std::string</code> would have to be created.</p>
<h3>Growth policy</h3>
<p>The library supports multiple growth policies through the <code>GrowthPolicy</code> template parameter. Three policies are provided by the library but you can easily implement your own if needed.</p>
<ul>
<li><b><a href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1ah_1_1power__of__two__growth__policy.html">tsl::ah::power_of_two_growth_policy.</a></b> Default policy used by <code><a class="el" href="classtsl_1_1array__map.html">tsl::array_map</a>/set</code>. This policy keeps the size of the bucket array of the hash table to a power of two. This constraint allows the policy to avoid the usage of the slow modulo operation to map a hash to a bucket, instead of <code>hash % 2<sup>n</sup></code>, it uses <code>hash &amp; (2<sup>n</sup> - 1)</code> (see <a href="https://en.wikipedia.org/wiki/Modulo_operation#Performance_issues">fast modulo</a>). Fast but this may cause a lot of collisions with a poor hash function as the modulo with a power of two only masks the most significant bits in the end.</li>
<li><b><a href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1ah_1_1prime__growth__policy.html">tsl::ah::prime_growth_policy.</a></b> Default policy used by <code><a class="el" href="namespacetsl.html#ac1a9ea8631baa6e45199f6f671822d1d">tsl::array_pg_map</a>/set</code>. The policy keeps the size of the bucket array of the hash table to a prime number. When mapping a hash to a bucket, using a prime number as modulo will result in a better distribution of the hash across the buckets even with a poor hash function. To allow the compiler to optimize the modulo operation, the policy use a lookup table with constant primes modulos (see <a href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1ah_1_1prime__growth__policy.html#details">API</a> for details). Slower than <code><a class="el" href="classtsl_1_1ah_1_1power__of__two__growth__policy.html">tsl::ah::power_of_two_growth_policy</a></code> but more secure.</li>
<li><b><a href="https://tessil.github.io/array-hash/doc/html/classtsl_1_1ah_1_1mod__growth__policy.html">tsl::ah::mod_growth_policy.</a></b> The policy grows the map by a customizable growth factor passed in parameter. It then just use the modulo operator to map a hash to a bucket. Slower but more flexible.</li>
</ul>
<p>To implement your own policy, you have to implement the following interface.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">struct custom_policy {</div><div class="line">    // Called on hash table construction, min_bucket_count_in_out is the minimum size</div><div class="line">    // that the hash table needs. The policy can change it to a higher bucket count if needed</div><div class="line">    custom_policy(std::size_t&amp; min_bucket_count_in_out);</div><div class="line"></div><div class="line">    // Return the bucket for the corresponding hash</div><div class="line">    std::size_t bucket_for_hash(std::size_t hash) const noexcept;</div><div class="line"></div><div class="line">    // Return the number of buckets that should be used on next growth</div><div class="line">    std::size_t next_bucket_count() const;</div><div class="line"></div><div class="line">    // Maximum number of buckets supported by the policy</div><div class="line">    std::size_t max_bucket_count() const;</div><div class="line">}</div></div><!-- fragment --><h3>Installation</h3>
<p>To use the library, just add the <a href="include/">include</a> directory to your include path. It is a <b>header-only</b> library.</p>
<p>If you use CMake, you can also use the <code>tsl::array_hash</code> exported target from the <a href="CMakeLists.txt">CMakeLists.txt</a> with <code>target_link_libraries</code>. </p><div class="fragment"><div class="line"># Example where the array-hash project is stored in a third-party directory</div><div class="line">add_subdirectory(third-party/array-hash)</div><div class="line">target_link_libraries(your_target PRIVATE tsl::array_hash)  </div></div><!-- fragment --><p> The code should work with any C++11 standard-compliant compiler and has been tested with GCC 4.8.4, Clang 3.5.0 and Visual Studio 2015.</p>
<p>To run the tests you will need the Boost Test library and CMake.</p>
<div class="fragment"><div class="line">git clone https://github.com/Tessil/array-hash.git</div><div class="line">cd array-hash/tests</div><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake ..</div><div class="line">cmake --build .</div><div class="line">./tsl_array_hash_tests</div></div><!-- fragment --><h3>Usage</h3>
<p>The API can be found <a href="https://tessil.github.io/array-hash/doc_without_string_view/html">here</a>. If <code>std::string_view</code> is available, the API changes slightly and can be found <a href="https://tessil.github.io/array-hash/doc/html/">here</a>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;tsl/array_map.h&gt;</div><div class="line">#include &lt;tsl/array_set.h&gt;</div><div class="line"></div><div class="line"></div><div class="line">int main() {</div><div class="line">    // Map of const char* to int</div><div class="line">    tsl::array_map&lt;char, int&gt; map = {{&quot;one&quot;, 1}, {&quot;two&quot;, 2}};</div><div class="line">    map[&quot;three&quot;] = 3;</div><div class="line">    map[&quot;four&quot;] = 4;</div><div class="line"></div><div class="line">    map.insert(&quot;five&quot;, 5);</div><div class="line">    map.insert_ks(&quot;six_with_extra_chars_we_ignore&quot;, 3, 6);</div><div class="line"></div><div class="line">    map.erase(&quot;two&quot;);</div><div class="line"></div><div class="line">    // When template parameter StoreNullTerminator is true (default) and there is no</div><div class="line">    // null character in the strings.</div><div class="line">    for(auto it = map.begin(); it != map.end(); ++it) {</div><div class="line">        std::cout &lt;&lt; &quot;{&quot; &lt;&lt; it.key() &lt;&lt; &quot;, &quot; &lt;&lt; it.value() &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    // If StoreNullTerminator is false for space efficiency or you are storing null characters, </div><div class="line">    // you can access to the size of the key.</div><div class="line">    for(auto it = map.begin(); it != map.end(); ++it) {</div><div class="line">        (std::cout &lt;&lt; &quot;{&quot;).write(it.key(), it.key_size()) &lt;&lt; &quot;, &quot; &lt;&lt; it.value() &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    // Better, use key_sv() if you compiler provides access to std::string_view.</div><div class="line">    for(auto it = map.begin(); it != map.end(); ++it) {</div><div class="line">        std::cout &lt;&lt; &quot;{&quot; &lt;&lt; it.key_sv() &lt;&lt; &quot;, &quot; &lt;&lt; it.value() &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    // Or if you just want the values.</div><div class="line">    for(int value: map) {</div><div class="line">        std::cout &lt;&lt; &quot;{&quot; &lt;&lt; value &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    // Map of const char32_t* to int</div><div class="line">    tsl::array_map&lt;char32_t, int&gt; map_char32 = {{U&quot;one&quot;, 1}, {U&quot;two&quot;, 2}};</div><div class="line">    map_char32[U&quot;three&quot;] = 3;</div><div class="line"></div><div class="line"></div><div class="line">    // Set of const char*</div><div class="line">    tsl::array_set&lt;char&gt; set = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;};</div><div class="line">    set.insert({&quot;four&quot;, &quot;five&quot;});</div><div class="line"></div><div class="line">    for(auto it = set.begin(); it != set.end(); ++it) {</div><div class="line">        std::cout &lt;&lt; &quot;{&quot; &lt;&lt; it.key() &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>License</h3>
<p>The code is licensed under the MIT license, see the [LICENSE file](LICENSE) for details. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
